{"constants":[{"id":"constant-1","name":"JenkinsUserName","hidden":false,"value":""},{"id":"constant-2","name":"JenkinsAPIToken","hidden":false,"value":""},{"id":"constant-3","name":"JenkinsURL","hidden":false,"value":""},{"id":"constant-4","name":"JenkinsJobName","hidden":false,"value":""},{"id":"constant-5","name":"JenkinsJobToken;","hidden":false,"value":""},{"id":"constant-6","name":"QTEST_TOKEN","hidden":false,"value":""},{"id":"constant-7","name":"ManagerURL","hidden":false,"value":""},{"id":"constant-8","name":"SCENARIO_PROJECT_ID","hidden":false,"value":""},{"id":"constant-9","name":"Scenario_URL","hidden":false,"value":""},{"id":"constant-10","name":"ChatOpsWebhook","hidden":false,"value":""}],"actions":[{"id":"action-1","name":"FormatWebIO","description":null,"code":"const PulseSdk = require('@qasymphony/pulse-sdk');\nconst request = require('request');\nconst xml2js = require('xml2js');\n\n// DO NOT EDIT exported \"handler\" function is the entrypoint\nexports.handler = async function({ event, constants, triggers }, context, callback) {\n  // TODO implement\n}\n"},{"id":"action-2","name":"ChatOpsEvent","description":null,"code":"/**\n * trigger name: ChatOpsEvent\n * call source: other Pulse Actions via emitEvent()\n * payload example:\n *   {\n *     \"message\": \"insert message contents here\"\n *   }\n * constants example:\n *  ChatOpsWebhook: https://hooks.slack.com/services/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\n * outputs: the \"message\" object in the payload will be sent to a configured Slack webhook\n * prerequisites: configured webhook connector for Slack\n * external documentation: https://api.slack.com/incoming-webhooks \n */\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    var str = body;\n    //console.log(str.message);\n\n    var request = require('request');\n    var slack_webhook = constants.ChatOpsWebhook;\n\n    //console.log('About to request slack webhook: ', slack_webhook);\n\n    request({\n        uri: slack_webhook,\n        method: 'POST',\n        json: { \"text\": JSON.stringify(str) }\n    }, function (error, response, body) { }\n    );\n}\n"},{"id":"action-3","name":"UpdateQTestAndLinkScenarioRequirements","description":null,"code":"/*\n * trigger name: UpdateQTestWithResults\n * call source: any and all Result Parser rules via emitEvent()\n * payload example:\n        {\n          \"projectId\": \"5\",\n          \"testcycle\": \"555555\",\n          \"logs\": [\n            {\n              \"status\": \"passed\",\n              \"name\": \"Test 1 Name\",\n              \"attachments\": [],\n              \"exe_start_date\": \"2020-10-30T14:56:22.357Z\",\n              \"exe_end_date\": \"2020-10-30T14:56:22.357Z\",\n              \"automation_content\": \"uniquely identfied string\",\n              \"module_names\": [\n                \"TEST CYCLE FOLDER NAME\"\n              ],\n              \"test_step_logs\": [\n                {\n                  \"description\": \"Step 1 description\",\n                  \"expected_result\": \"Step 1 expected\",\n                  \"actual_result\": \"Step 1 result\",\n                  \"order\": 1,\n                  \"status\": \"passed\"\n                },\n                {\n                  \"description\": \"Step 2 description\",\n                  \"expected_result\": \"Step 2 expected\",\n                  \"actual_result\": \"Step 2 result\",\n                  \"order\": 2,\n                  \"status\": \"passed\"\n                },\n                {\n                  \"description\": \"Step 3 description\",\n                  \"expected_result\": \"Step 3 expected\",\n                  \"actual_result\": \"Step 3 result\",\n                  \"order\": 3,\n                  \"status\": \"passed\"\n                }\n                }\n              ]\n            }\n          ]\n        }\n * constants:\n *  QTEST_TOKEN: the qTest user bearer token from the API/SDK section of the 'Resources' area\n        Ex. 02e74731-2f6e-4b95-b928-1596a68881e2\n *  Manager_URL: the base qTest Manager domain with no protocol information, https is expected by the script\n        Ex. demo.qtestnet.com\n * outputs: standardized construct to be consumed by the qTest auto-test-logs API\n * external documentation: https://api.qasymphony.com/#/test-log/submitAutomationTestLogs2\n * Pulse events called: ChatOpsEvent\n */\n\nconst request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\nconst ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst Features = {\n    getIssueLinkByFeatureName(qtestToken, scenarioProjectId, name) {\n        return new ScenarioSdk.Features({ qtestToken, scenarioProjectId }).getFeatures(`\"${name}\"`);\n    }\n};\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    var payload = body;\n\n    var testLogs = payload.logs;\n    var cycleId = payload.testcycle;\n    var projectId = payload.projectId;\n    var queueStatus = 'IN_WAITING'; // IN_WAITING, IN_PROCESSING, FAILED, PENDING and SUCCESS\n    var queueId = 0;\n\n    var standardHeaders = {\n        'Content-Type': 'application/json',\n        'Authorization': `bearer ${constants.QTEST_TOKEN}`\n    }\n\n    function createLogsAndTCs() {\n        var opts = {\n            url: 'http://' + constants.ManagerURL + '/api/v3/projects/' + projectId + '/auto-test-logs?type=automation',\n            json: true,\n            headers: standardHeaders,\n            body: {\n                test_cycle: cycleId,\n                test_logs: testLogs\n            }\n        };\n\n        return request.post(opts, function (err, response, resbody) {\n\n            if (err) {\n                Promise.reject(err);\n                console.log(err);\n            }\n            else {\n                if (response.body.type == 'AUTOMATION_TEST_LOG') {\n                  queueId = response.body.id;\n                    Promise.resolve('Results queued successfully.');\n                    emitEvent('ChatOpsEvent', { message: '[INFO]: Results queued successfully for id: ' + resbody.id});\n                    console.log('[INFO]: Results queued successfully for id: ' + resbody.id);\n                    checkQueueStatus(queueId);\n                }\n                else {\n                    emitEvent('ChatOpsEvent', { message: 'Unable to upload test results.' });\n                    Promise.reject('[ERROR]: Unable to upload test results.  See logs for details.');\n                    emitEvent('ChatOpsEvent', { message: '[ERROR]: ' + JSON.stringify(resbody) });\n                    console.log('[ERROR]: ' + JSON.stringify(resbody));\n                }\n            }\n        });\n    };\n\n    async function checkQueueStatus(id) {\n        var opts = {\n            url: 'https://' + constants.ManagerURL + '/api/v3/projects/queue-processing/' + id,\n            json: true,\n            headers: standardHeaders\n        };\n        \n        var queueCounter = 0;\n        const queueProcessing = ['IN_WAITING', 'IN_PROCESSING', 'PENDING'];\n\n        await sleep(2000);\n\n        while (queueProcessing.includes(queueStatus))  {\n\n          await request(opts, function (err, response, resbody) {\n              if (err) {\n                  Promise.reject(err);\n                  console.log(err);\n                  return;\n              }\n              else {\n                queueStatus = resbody.state;\n                Promise.resolve('Queue checked successfully.');\n                emitEvent('ChatOpsEvent', { message: '[INFO]: Queue checked for id: ' + id + ', status is now: ' + queueStatus});\n                console.log('[INFO]: Queue checked for id: ' + id + ', status is now: ' + queueStatus);\n                if (queueStatus == 'FAILED') {\n                    emitEvent('ChatOpsEvent', { message: '[ERROR]: ' + resbody.content});\n                    console.log('[ERROR]: ' + resbody.content);\n                }\n                if (!queueProcessing.includes(queueStatus)) {\n                    console.log('About to call Link Requirements Rule.');\n                    emitEvent('LinkScenarioRequirements', payload);\n                }\n              }\n          });\n\n          queueCounter++;\n\n          if(queueCounter > 30) {\n            console.log('[WARNING]: Queue id: ' + id + ' is still in processing after 60 seconds, likely caused by heavy traffic.')\n            return;\n          } else {                \n                await sleep(2000);\n            }\n        }\n        return;\n    };\n\n    function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n    createLogsAndTCs();\n}"},{"id":"action-4","name":"LinkScenarioRequirements","description":null,"code":"const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\nconst ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconsole.log(\"Starting Link Requirements Action\");\n    \nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    \n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n    var payload = body;\n\n    var testLogs = payload.logs;\n    var projectId = payload.projectId;\n\n    var standardHeaders = {\n        'Content-Type': 'application/json',\n        'Authorization': `bearer ${constants.QtestToken}`,\n        'x-scenario-project-id': constants.ScenarioProjectID\n    }\n\n    const options = {\n        url: constants.ScenarioURL + '/api/features',\n        method: 'GET',\n        headers: standardHeaders\n    };\n\n    var features;\n    request.get(options, function (optserr, optsresponse, resbody) {\n        if (optserr) {\n            console.log(\"Problem Getting Feature List: \" + optserr);\n        }\n        else {\n            console.log(\"Got Features List: \" + resbody);\n            features = JSON.parse(resbody);\n            LinkRequirements();\n        }\n    });\n    \n    // This makes a best effort to link if test cases exist. Not if you just uploaded via the auto-test-logs endpoint, the job is batched and may not be completed yet\n    function LinkRequirements() {\n        testLogs.forEach(function (testcase) {\n        \n        // var matchingFeature = features.find(x => x.name === testcase.featureName);\n\n        var matchingFeatures = features.filter(feature => feature.name === testcase.featureName);\n\n        if (matchingFeatures.length === 0) {\n            return\n        }\n\n        // if(!matchingFeature)\n        //     return;\n\n        matchingFeatures.forEach(function (matchingFeature) {             \n            var reqopts = getReqBody(matchingFeature.issueKey);\n            request.post(reqopts, function (err, response, featureResBody) {\n\n                if (err) {\n                    console.log(\"Problem getting requirement: \" + err );\n                }\n                else {\n                    if (featureResBody.items.length === 0) { // No corresponding feature exists in scenario\n                        console.log('[Info] No featureResBody item found')\n                        return;\n                    }\n\n                    var reqid = featureResBody.items[0].id;\n                    var tcopts = getTCBody(testcase.name);\n\n                    request.post(tcopts, function (tcerr, tcresponse, testCaseResBody) {\n\n                        if (tcerr) {\n                            console.log(\"Problem getting test case: \" + err );\n                        }\n                        else {\n                            if(testCaseResBody.items.length === 0) { // Test Case Doesn't yet exist - we'll try this another time\n                                console.log('[Info] No testCaseResBody item found')\n                                console.log(tcresponse);\n                                return;\n                            }\n\n                            var tcid = testCaseResBody.items[0].id;\n                            var linkopts = getLinkBody(reqid, tcid);\n\n                            request.post(linkopts, function (optserr, optsresponse, resbody) {\n                                if (optserr) {\n                                    console.log('[Error] A link is failed to be added.', optserr)\n                                    console.log(\"Problem creating test link to requirement: \" + err);\n                                }\n                                else {\n                                    // Success, we added a link!\n                                    console.log('[Info] A link is added')\n                                    console.log(\"link added for TC: \" + testcase.name + \" to requirement \" + matchingFeature.issueKey);\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n         })\n\n    });\n\n    }\n\n    function getTCBody(TCName) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHeaders,\n            body: {\n                \"object_type\": \"test-cases\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name = '\" + TCName + \"'\"\n            }\n        };\n    }\n\n    function getReqBody(key) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHeaders,\n            body: {\n                \"object_type\": \"requirements\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name ~ '\" + key + \"'\"\n            }\n        };\n    }\n\n    function getLinkBody(reqid, tcid) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/requirements/\" + reqid + \"/link?type=test-cases\",\n            json: true,\n            headers: standardHeaders,\n            body: [\n                tcid\n            ]\n        };\n    }\n}"},{"id":"action-5","name":"UpdateScenarioWithResults","description":null,"code":"const ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst StepSdk = {\n    getStepSdk(qtestToken, scenarioProjectId) {\n        return new ScenarioSdk.Steps({ qtestToken, scenarioProjectId });\n    }\n}\n\nconst Steps = {\n    updateStepResults(stepSdk, name, status, issueId = null, keyword = null) {\n        return stepSdk.getSteps(name, keyword, issueId). // issueId only available from Pulse v9.2\n            then(steps => Promise.all(steps.map(step => stepSdk.updateStep(step.id, Object.assign(step, { status })))))\n            .catch(function (err) {\n                console.log('Error updating colors: ', err);\n            });\n    }\n};\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    var payload = body;\n    var testLogs = payload.logs;\n\n    stepSdk = StepSdk.getStepSdk(constants.QTEST_TOKEN, constants.SCENARIO_PROJECT_ID);\n    \n    for (var res of testLogs) {\n        for (var step of res[\"test_step_logs\"]) {\n            // If for any reason you change the step description be certain to edit the following line to create a match for the Scenario SDK!!\n            var stepName = step.description.slice(step.description.indexOf(' ')).trim();\n            var stepStatus = step.status;\n            var stepKeyword = step.keyword;\n            var issueId = step.issueId;\n\n            // Undefined means no step definition existed and it should fail\n            if (stepStatus == \"undefined\") {\n                stepStatus = \"failed\";\n            }\n\n            // one of PASSED (green), FAILED (red), or SKIPPED (yellow)\n            stepStatus = stepStatus.toUpperCase();\n\n            // Call the pulse API to update step results\n            try {\n                console.log(\"Calling updateStepResults with: \" + JSON.stringify(stepSdk) + \", \" + stepName + \", \" + stepStatus + \", \" + issueId + \", \" + stepKeyword);\n                Steps.updateStepResults(stepSdk, stepName, stepStatus, issueId, stepKeyword);\n            }\n            catch {\n                console.log(\"Error calling updateStepResults\");\n            }\n        }\n    }\n}"},{"id":"action-6","name":"FormatJavaCucumber","description":null,"code":"/**\n * call source: delivery script from CI Tool (Jenkins, Bamboo, TeamCity, CircleCI, etc), Launch, locally executed\n *              see 'delivery' subdirectory in this repository\n * payload example:\n * {\n *   properties: 'example value'\n *   arrayOfItems: [ { <properties and example values> } ]\n * }\n * constants:\n * - SCENARIO_PROJECT_ID: 84d46c6a-d39d-11e9-bb65-2a2ae2dbcce4\n * - QTEST_TOKEN: 84d46c6a-d39d-11e9-bb65-2a2ae2dbcce4\n * outputs:\n * - The unformatted items in the payload will be formatted into qTest test case\n * - The test cases then will be added to qTest project\n * - The unformatted result will be sent to the trigger \"TriggerName\"\n * - The ChatOps channel (if there is any) will notificate the result or error\n */\n\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    var payload = body;\n    var projectId = payload.projectId;\n    var cycleId = payload.testcycle;\n\n    let testResults = JSON.parse(Buffer.from(payload.result, 'base64').toString('ascii'));\n\n    var testLogs = [];\n    //console.log(\"TEST RESULTS: \" + testResults);\n\n    //emitEvent('ChatOpsEvent', { TESTRESULTS: testResults });\n\n    testResults.forEach(function (feature) {\n        var featureName = feature.name;\n        feature.elements.forEach(function (testCase) {\n\n            if (!testCase.name)\n                testCase.name = \"Unnamed\";\n\n            TCStatus = \"passed\";\n\n            var reportingLog = {\n                exe_start_date: new Date(), // TODO These could be passed in\n                exe_end_date: new Date(),\n                module_names: [\n                    featureName\n                ],\n                name: testCase.name,\n                automation_content: feature.uri + \"#\" + testCase.name\n            };\n\n            var testStepLogs = [];\n            order = 0;\n            stepNames = [];\n            attachments = [];\n\n            testCase.steps.forEach(function (step) {\n                stepNames.push(step.name);\n\n                var status = step.result.status;\n                var actual = step.name;\n\n                if (TCStatus == \"passed\" && status == \"skipped\") {\n                    TCStatus = \"skipped\";\n                }\n                if (status == \"failed\") {\n                    TCStatus = \"failed\";\n                    actual = step.result.error_message;\n                }\n                if (status == \"undefined\") {\n                    TCStatus = \"incomplete\";\n                    status = \"incomplete\";                    \n                    emitEvent('ChatOpsEvent', { message: \"Step result not found: \" + step.name + \"; marking as incomplete.\" });\n                }\n\n                // Are there an attachment for this step?\n                if (\"embeddings\" in step) {\n                    console.log(\"Has attachment\");\n\n                    attCount = 0;\n                    step.embeddings.forEach(function (att) {\n                        attCount++;\n                        var attachment = {\n                            name: step.name + \" Attachment \" + attCount,\n                            \"content_type\": att.mime_type,\n                            data: att.data\n                        };\n                        console.log(\"Attachment: \" + attachment.name)\n\n                        attachments.push(attachment);\n                    });\n                }\n\n                var expected = step.keyword + \" \" + step.name;\n\n                if (\"location\" in step.match) {\n                    expected = step.match.location;\n                }\n\n                var stepLog = {\n                    order: order,\n                    description: step.keyword + ' ' + step.name,\n                    expected_result: step.name,\n                    actual_result: actual,\n                    status: status\n                };\n\n                testStepLogs.push(stepLog);\n                order++;\n            });\n\n            reportingLog.attachments = attachments;\n            reportingLog.description = stepNames.join(\"<br/>\");\n            reportingLog.status = TCStatus;\n            reportingLog.test_step_logs = testStepLogs;\n            reportingLog.featureName = featureName;\n            testLogs.push(reportingLog);\n        });\n    });\n\n    var formattedResults = {\n        \"projectId\": projectId,\n        \"testcycle\": cycleId,\n        \"logs\": testLogs\n    };\n\n    emitEvent('UpdateQTestAndLinkScenarioRequirements', formattedResults);\n\n}\n"},{"id":"action-7","name":"TriggerJenkins","description":null,"code":"/**\n * call source: Repository (Bitbucket, Github, Gitlab, etc), Scenario Action\n * payload example: N/A, trigger only\n * constants:\n *  JenkinsUserName: admin\n *  JenkinsAPIToken: fa96ad2f-5e1c-4562-a14d-98a94ba9bab1\n *  JenkinsURL: jenkins.yourdomain.com:8080\n *  JenkinsJobName: CucumberBuildJob\n *  JenkinsJobToken: fa96ad2f-5e1c-4562-a14d-98a94ba9bab1\n * outputs:\n *  The specified build job will be triggered in Jenkins\n */\n\nconst request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n        var url = \"http://\" + constants.JenkinsUserName + \":\" + constants.JenkinsAPIToken + \"@\" + \n        constants.JenkinsURL + '/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\":\",//crumb)';\n\n        request.get({url:url, insecure: true}, function(err, response, body) {\n            if(!err) {\n                var crumb = body.split(\":\")[1];\n\n                var joburl = \"http://\" + constants.JenkinsUserName + \":\" + constants.JenkinsAPIToken + \"@\" + \n                        constants.JenkinsURL + \"/job/\" + constants.JenkinsJobName + \"/build?token=\" + constants.JenkinsJobToken;\n                var opts = {\n                    url: joburl,\n                    insecure: true,\n                    contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n                    headers: {\n                        \"Jenkins-Crumb\": crumb\n                    }\n                };\n\n                request.post(opts, function(err, res, bd) {\n                    if(!err) {\n                        emitEvent('ChatOpsEvent', { message: \"Jenkins Build just kicked off for project: \" + constants.JenkinsJobName });\n                    }\n                    else {\n                        emitEvent('ChatOpsEvent', { message: \"Jenkins Build kickoff failed for project: \" + constants.JenkinsJobName + \" & Error: \" + err });\n                    }\n                });\n            }\n            else {\n                emitEvent('ChatOpsEvent', { message: \"Jenkins Build kickoff failed for project: \" + constants.JenkinsJobName + \" & Error: \" + err  }); \n            }\n        });\n}\n"}],"triggers":[{"id":"trigger-1","name":"ChatOpsEvent"},{"id":"trigger-2","name":"LinkScenarioRequirements"},{"id":"trigger-3","name":"UpdateQTestAndLinkScenarioRequirements"},{"id":"trigger-4","name":"UploadJavaCucumber"},{"id":"trigger-5","name":"TriggerJenkins"}],"rules":[{"id":"rule-6","name":"TriggerJenkins","active":true,"triggerId":"trigger-5","actionIds":["action-7"],"tags":[]},{"id":"rule-7","name":"UploadAndFormatJavaCucumber","active":true,"triggerId":"trigger-4","actionIds":["action-6"],"tags":[]},{"id":"rule-8","name":"UpdateQTestAndLinkScenarioRequirements","active":true,"triggerId":"trigger-3","actionIds":["action-3","action-5"],"tags":[]},{"id":"rule-9","name":"LinkScenarioRequirements","active":true,"triggerId":"trigger-2","actionIds":["action-4"],"tags":[]},{"id":"rule-10","name":"ChatOpsEvent","active":true,"triggerId":"trigger-1","actionIds":["action-2"],"tags":[]}]}
